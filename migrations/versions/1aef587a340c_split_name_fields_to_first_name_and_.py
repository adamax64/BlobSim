"""Split name fields to first_name and last_name

Revision ID: 1aef587a340c
Revises: 6c6b8a6b6b87
Create Date: 2025-05-29 21:22:16.655253

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import table, column


# revision identifiers, used by Alembic.
revision: str = '1aef587a340c'
down_revision: Union[str, None] = '6c6b8a6b6b87'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Add new columns as nullable first
    op.add_column('blobs', sa.Column('first_name', sa.String(), nullable=True), schema='BCS')
    op.add_column('blobs', sa.Column('last_name', sa.String(), nullable=True), schema='BCS')
    op.add_column('name_suggestions', sa.Column('first_name', sa.String(), nullable=True), schema='BCS')
    op.add_column('name_suggestions', sa.Column('last_name', sa.String(), nullable=True), schema='BCS')

    # Create table objects for data migration
    blobs_table = table(
        'blobs',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String),
        schema='BCS'
    )

    suggestions_table = table(
        'name_suggestions',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String),
        schema='BCS'
    )

    # Migrate data for blobs table
    connection = op.get_bind()
    for row in connection.execute(sa.select(blobs_table.c.name)):
        if row.name:
            name_parts = row.name.split(' ', 1)
            first = name_parts[0]
            last = name_parts[1] if len(name_parts) > 1 else ''
            connection.execute(
                blobs_table.update()
                .where(blobs_table.c.name == row.name)
                .values(first_name=first or '', last_name=last or '')
            )

    # Migrate data for name_suggestions table
    for row in connection.execute(sa.select(suggestions_table.c.name)):
        if row.name:
            name_parts = row.name.split(' ', 1)
            first = name_parts[0]
            last = name_parts[1] if len(name_parts) > 1 else ''
            connection.execute(
                suggestions_table.update()
                .where(suggestions_table.c.name == row.name)
                .values(first_name=first or '', last_name=last or '')
            )

    # Create blobs_new sequence, then table with default
    op.execute('CREATE SEQUENCE IF NOT EXISTS "BCS".blobs_new_id_seq')
    op.execute('''
        CREATE TABLE "BCS".blobs_new (
            id INTEGER PRIMARY KEY DEFAULT nextval('"BCS".blobs_new_id_seq'::regclass),
            first_name VARCHAR NOT NULL,
            last_name VARCHAR NOT NULL,
            strength FLOAT,
            learning FLOAT,
            integrity INTEGER,
            born BIGINT,
            terminated BIGINT,
            debut INTEGER,
            contract INTEGER,
            money INTEGER DEFAULT 0,
            points INTEGER DEFAULT 0,
            bronze_medals INTEGER DEFAULT 0,
            silver_medals INTEGER DEFAULT 0,
            gold_medals INTEGER DEFAULT 0,
            season_victories INTEGER DEFAULT 0,
            bronze_trophies INTEGER DEFAULT 0,
            silver_trophies INTEGER DEFAULT 0,
            gold_trophies INTEGER DEFAULT 0,
            championships INTEGER DEFAULT 0,
            grandmasters INTEGER DEFAULT 0,
            league_id INTEGER,
            parent_id INTEGER,
            FOREIGN KEY(league_id) REFERENCES "BCS".leagues(id),
            UNIQUE(first_name, last_name)
        )
    ''')
    op.execute('ALTER SEQUENCE "BCS".blobs_new_id_seq OWNED BY "BCS".blobs_new.id')

    # Create name_suggestions_new sequence, then table with default
    op.execute('CREATE SEQUENCE IF NOT EXISTS "BCS".name_suggestions_new_id_seq')
    op.execute('''
        CREATE TABLE "BCS".name_suggestions_new (
            id INTEGER PRIMARY KEY DEFAULT nextval('"BCS".name_suggestions_new_id_seq'::regclass),
            first_name VARCHAR,
            last_name VARCHAR NOT NULL,
            parent_id INTEGER,
            created TIMESTAMP,
            FOREIGN KEY(parent_id) REFERENCES "BCS".blobs_new(id),
            UNIQUE(first_name, last_name)
        )
    ''')
    op.execute('ALTER SEQUENCE "BCS".name_suggestions_new_id_seq OWNED BY "BCS".name_suggestions_new.id')

    # Copy data
    op.execute('''
        INSERT INTO "BCS".blobs_new (
            id, first_name, last_name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        )
        SELECT
            id, first_name, last_name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        FROM "BCS".blobs
    ''')

    op.execute('''
        INSERT INTO "BCS".name_suggestions_new (
            id, first_name, last_name, parent_id, created
        )
        SELECT
            id, first_name, last_name, parent_id, created
        FROM "BCS".name_suggestions
    ''')

    # Drop old tables
    op.execute('DROP TABLE IF EXISTS "BCS".blobs CASCADE')
    op.execute('DROP TABLE IF EXISTS "BCS".name_suggestions CASCADE')

    # Rename new tables
    op.execute('ALTER TABLE "BCS".blobs_new RENAME TO blobs')
    op.execute('ALTER TABLE "BCS".name_suggestions_new RENAME TO name_suggestions')

    # Rename sequences to match new table names
    op.execute('ALTER SEQUENCE IF EXISTS "BCS".blobs_new_id_seq RENAME TO blobs_id_seq')
    op.execute('ALTER SEQUENCE IF EXISTS "BCS".name_suggestions_new_id_seq RENAME TO name_suggestions_id_seq')

    # Create self-referential foreign key trigger/function after renaming
    op.execute('''
        CREATE OR REPLACE FUNCTION "BCS".check_blobs_parent_id()
        RETURNS TRIGGER AS $$
        BEGIN
            IF NEW.parent_id IS NOT NULL THEN
                IF NOT EXISTS (SELECT 1 FROM "BCS".blobs WHERE id = NEW.parent_id) THEN
                    RAISE EXCEPTION 'Foreign key violation: parent_id is not in blobs';
                END IF;
            END IF;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    ''')
    op.execute('''
        CREATE TRIGGER fk_blobs_parent_id
        BEFORE INSERT ON "BCS".blobs
        FOR EACH ROW
        EXECUTE FUNCTION "BCS".check_blobs_parent_id();
    ''')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Add back the name columns
    op.add_column('name_suggestions', sa.Column('name', sa.VARCHAR(), nullable=True))
    op.add_column('blobs', sa.Column('name', sa.VARCHAR(), nullable=True))

    # Create table objects for data migration
    blobs_table = table(
        'blobs',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String),
        schema='BCS'
    )

    suggestions_table = table(
        'name_suggestions',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String),
        schema='BCS'
    )

    # Migrate data back
    connection = op.get_bind()
    for row in connection.execute(sa.select(blobs_table.c.first_name, blobs_table.c.last_name)):
        full_name = f"{row.first_name or ''} {row.last_name or ''}".strip()
        connection.execute(
            blobs_table.update()
            .where(
                (blobs_table.c.first_name == row.first_name) &
                (blobs_table.c.last_name == row.last_name)
            )
            .values(name=full_name)
        )

    for row in connection.execute(sa.select(suggestions_table.c.first_name, suggestions_table.c.last_name)):
        full_name = f"{row.first_name or ''} {row.last_name or ''}".strip()
        connection.execute(
            suggestions_table.update()
            .where(
                (suggestions_table.c.first_name == row.first_name) &
                (suggestions_table.c.last_name == row.last_name)
            )
            .values(name=full_name)
        )

    # Create new tables with original schema
    op.execute('''
        CREATE TABLE "BCS".blobs_new (
            id INTEGER PRIMARY KEY,
            name VARCHAR,
            strength FLOAT,
            learning FLOAT,
            integrity INTEGER,
            born BIGINT,
            terminated BIGINT,
            debut INTEGER,
            contract INTEGER,
            money INTEGER DEFAULT 0,
            points INTEGER DEFAULT 0,
            bronze_medals INTEGER DEFAULT 0,
            silver_medals INTEGER DEFAULT 0,
            gold_medals INTEGER DEFAULT 0,
            season_victories INTEGER DEFAULT 0,
            bronze_trophies INTEGER DEFAULT 0,
            silver_trophies INTEGER DEFAULT 0,
            gold_trophies INTEGER DEFAULT 0,
            championships INTEGER DEFAULT 0,
            grandmasters INTEGER DEFAULT 0,
            league_id INTEGER,
            parent_id INTEGER,
            FOREIGN KEY(league_id) REFERENCES "BCS".leagues(id),
            UNIQUE(name)
        )
    ''')

    op.execute('''
        CREATE TABLE "BCS".name_suggestions_new (
            id INTEGER PRIMARY KEY,
            name VARCHAR,
            parent_id INTEGER,
            created TIMESTAMP,
            FOREIGN KEY(parent_id) REFERENCES "BCS".blobs_new(id),
            UNIQUE(name)
        )
    ''')

    # Copy data
    op.execute('''
        INSERT INTO "BCS".blobs_new (
            id, name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        )
        SELECT
            id, name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        FROM "BCS".blobs
    ''')

    op.execute('''
        INSERT INTO "BCS".name_suggestions_new (
            id, name, parent_id, created
        )
        SELECT
            id, name, parent_id, created
        FROM "BCS".name_suggestions
    ''')

    # Drop old tables
    op.execute('DROP TABLE IF EXISTS "BCS".blobs CASCADE')
    op.execute('DROP TABLE IF EXISTS "BCS".name_suggestions CASCADE')

    # Rename new tables
    op.execute('ALTER TABLE "BCS".blobs_new RENAME TO blobs')
    op.execute('ALTER TABLE "BCS".name_suggestions_new RENAME TO name_suggestions')

    # Rename sequences to match new table names
    op.execute('ALTER SEQUENCE IF EXISTS "BCS".blobs_new_id_seq RENAME TO blobs_id_seq')
    op.execute('ALTER SEQUENCE IF EXISTS "BCS".name_suggestions_new_id_seq RENAME TO name_suggestions_id_seq')

    # Create self-referential foreign key trigger/function after renaming
    op.execute('''
        CREATE OR REPLACE FUNCTION "BCS".check_blobs_parent_id()
        RETURNS TRIGGER AS $$
        BEGIN
            IF NEW.parent_id IS NOT NULL THEN
                IF NOT EXISTS (SELECT 1 FROM "BCS".blobs WHERE id = NEW.parent_id) THEN
                    RAISE EXCEPTION 'Foreign key violation: parent_id is not in blobs';
                END IF;
            END IF;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    ''')
    op.execute('''
        CREATE TRIGGER fk_blobs_parent_id
        BEFORE INSERT ON "BCS".blobs
        FOR EACH ROW
        EXECUTE FUNCTION "BCS".check_blobs_parent_id();
    ''')
    # ### end Alembic commands ###
