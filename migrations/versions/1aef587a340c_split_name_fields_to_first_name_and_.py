"""Split name fields to first_name and last_name

Revision ID: 1aef587a340c
Revises: 6c6b8a6b6b87
Create Date: 2025-05-29 21:22:16.655253

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import table, column


# revision identifiers, used by Alembic.
revision: str = '1aef587a340c'
down_revision: Union[str, None] = '6c6b8a6b6b87'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Add new columns as nullable first
    op.add_column('blobs', sa.Column('first_name', sa.String(), nullable=True))
    op.add_column('blobs', sa.Column('last_name', sa.String(), nullable=True))
    op.add_column('name_suggestions', sa.Column('first_name', sa.String(), nullable=True))
    op.add_column('name_suggestions', sa.Column('last_name', sa.String(), nullable=True))

    # Create table objects for data migration
    blobs_table = table(
        'blobs',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String)
    )

    suggestions_table = table(
        'name_suggestions',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String)
    )

    # Migrate data for blobs table
    connection = op.get_bind()
    for row in connection.execute(sa.select(blobs_table.c.name)):
        if row.name:
            name_parts = row.name.split(' ', 1)
            first = name_parts[0]
            last = name_parts[1] if len(name_parts) > 1 else ''
            connection.execute(
                blobs_table.update()
                .where(blobs_table.c.name == row.name)
                .values(first_name=first or '', last_name=last or '')
            )

    # Migrate data for name_suggestions table
    for row in connection.execute(sa.select(suggestions_table.c.name)):
        if row.name:
            name_parts = row.name.split(' ', 1)
            first = name_parts[0]
            last = name_parts[1] if len(name_parts) > 1 else ''
            connection.execute(
                suggestions_table.update()
                .where(suggestions_table.c.name == row.name)
                .values(first_name=first or '', last_name=last or '')
            )

    # Create new tables with desired schema
    op.execute('''
        CREATE TABLE blobs_new (
            id INTEGER PRIMARY KEY,
            first_name VARCHAR NOT NULL,
            last_name VARCHAR NOT NULL,
            strength FLOAT,
            learning FLOAT,
            integrity INTEGER,
            born BIGINT,
            terminated BIGINT,
            debut INTEGER,
            contract INTEGER,
            money INTEGER DEFAULT 0,
            points INTEGER DEFAULT 0,
            bronze_medals INTEGER DEFAULT 0,
            silver_medals INTEGER DEFAULT 0,
            gold_medals INTEGER DEFAULT 0,
            season_victories INTEGER DEFAULT 0,
            bronze_trophies INTEGER DEFAULT 0,
            silver_trophies INTEGER DEFAULT 0,
            gold_trophies INTEGER DEFAULT 0,
            championships INTEGER DEFAULT 0,
            grandmasters INTEGER DEFAULT 0,
            league_id INTEGER,
            parent_id INTEGER,
            FOREIGN KEY(league_id) REFERENCES leagues(id),
            UNIQUE(first_name, last_name)
        )
    ''')

    # Add self-referential foreign key after table creation
    op.execute('''
        CREATE TRIGGER fk_blobs_parent_id
        BEFORE INSERT ON blobs_new
        FOR EACH ROW
        WHEN NEW.parent_id IS NOT NULL
        BEGIN
            SELECT RAISE(ROLLBACK, 'Foreign key violation: parent_id is not in blobs')
            WHERE NOT EXISTS (SELECT 1 FROM blobs_new WHERE id = NEW.parent_id);
        END;
    ''')

    op.execute('''
        CREATE TABLE name_suggestions_new (
            id INTEGER PRIMARY KEY,
            first_name VARCHAR,
            last_name VARCHAR NOT NULL,
            parent_id INTEGER,
            created DATETIME,
            FOREIGN KEY(parent_id) REFERENCES blobs_new(id),
            UNIQUE(first_name, last_name)
        )
    ''')

    # Copy data
    op.execute('''
        INSERT INTO blobs_new (
            id, first_name, last_name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        )
        SELECT
            id, first_name, last_name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        FROM blobs
    ''')

    op.execute('''
        INSERT INTO name_suggestions_new (
            id, first_name, last_name, parent_id, created
        )
        SELECT
            id, first_name, last_name, parent_id, created
        FROM name_suggestions
    ''')

    # Drop old tables
    op.drop_table('blobs')
    op.drop_table('name_suggestions')

    # Rename new tables
    op.rename_table('blobs_new', 'blobs')
    op.rename_table('name_suggestions_new', 'name_suggestions')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Add back the name columns
    op.add_column('name_suggestions', sa.Column('name', sa.VARCHAR(), nullable=True))
    op.add_column('blobs', sa.Column('name', sa.VARCHAR(), nullable=True))

    # Create table objects for data migration
    blobs_table = table(
        'blobs',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String)
    )

    suggestions_table = table(
        'name_suggestions',
        column('name', sa.String),
        column('first_name', sa.String),
        column('last_name', sa.String)
    )

    # Migrate data back
    connection = op.get_bind()
    for row in connection.execute(sa.select(blobs_table.c.first_name, blobs_table.c.last_name)):
        full_name = f"{row.first_name or ''} {row.last_name or ''}".strip()
        connection.execute(
            blobs_table.update()
            .where(
                (blobs_table.c.first_name == row.first_name) &
                (blobs_table.c.last_name == row.last_name)
            )
            .values(name=full_name)
        )

    for row in connection.execute(sa.select(suggestions_table.c.first_name, suggestions_table.c.last_name)):
        full_name = f"{row.first_name or ''} {row.last_name or ''}".strip()
        connection.execute(
            suggestions_table.update()
            .where(
                (suggestions_table.c.first_name == row.first_name) &
                (suggestions_table.c.last_name == row.last_name)
            )
            .values(name=full_name)
        )

    # Create new tables with original schema
    op.execute('''
        CREATE TABLE blobs_new (
            id INTEGER PRIMARY KEY,
            name VARCHAR,
            strength FLOAT,
            learning FLOAT,
            integrity INTEGER,
            born BIGINT,
            terminated BIGINT,
            debut INTEGER,
            contract INTEGER,
            money INTEGER DEFAULT 0,
            points INTEGER DEFAULT 0,
            bronze_medals INTEGER DEFAULT 0,
            silver_medals INTEGER DEFAULT 0,
            gold_medals INTEGER DEFAULT 0,
            season_victories INTEGER DEFAULT 0,
            bronze_trophies INTEGER DEFAULT 0,
            silver_trophies INTEGER DEFAULT 0,
            gold_trophies INTEGER DEFAULT 0,
            championships INTEGER DEFAULT 0,
            grandmasters INTEGER DEFAULT 0,
            league_id INTEGER,
            parent_id INTEGER,
            FOREIGN KEY(league_id) REFERENCES leagues(id),
            UNIQUE(name)
        )
    ''')

    # Add self-referential foreign key after table creation
    op.execute('''
        CREATE TRIGGER fk_blobs_parent_id
        BEFORE INSERT ON blobs_new
        FOR EACH ROW
        WHEN NEW.parent_id IS NOT NULL
        BEGIN
            SELECT RAISE(ROLLBACK, 'Foreign key violation: parent_id is not in blobs')
            WHERE NOT EXISTS (SELECT 1 FROM blobs_new WHERE id = NEW.parent_id);
        END;
    ''')

    op.execute('''
        CREATE TABLE name_suggestions_new (
            id INTEGER PRIMARY KEY,
            name VARCHAR,
            parent_id INTEGER,
            created DATETIME,
            FOREIGN KEY(parent_id) REFERENCES blobs_new(id)
        )
    ''')

    # Copy data
    op.execute('''
        INSERT INTO blobs_new (
            id, name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        )
        SELECT
            id, name, strength, learning, integrity,
            born, terminated, debut, contract, money, points,
            bronze_medals, silver_medals, gold_medals,
            season_victories, bronze_trophies, silver_trophies,
            gold_trophies, championships, grandmasters,
            league_id, parent_id
        FROM blobs
    ''')

    op.execute('''
        INSERT INTO name_suggestions_new (
            id, name, parent_id, created
        )
        SELECT
            id, name, parent_id, created
        FROM name_suggestions
    ''')

    # Drop old tables
    op.drop_table('blobs')
    op.drop_table('name_suggestions')

    # Rename new tables
    op.rename_table('blobs_new', 'blobs')
    op.rename_table('name_suggestions_new', 'name_suggestions')
    # ### end Alembic commands ###
